import torch
import torch.nn.functional as F

class SAGS:
    def __init__(self,
                 inter_sigma=0.98,
                 multi_kernel_sizes=None,
                 multi_sigmas=None,
                 multi_weights=None,
                 device='cuda'):
        if multi_kernel_sizes is None:
            multi_kernel_sizes = [5, 13, 9]
        if multi_sigmas is None:
            multi_sigmas = [0.82, 4.74, 0.75]
        if multi_weights is None:
            multi_weights = [0.52, 0.43, 0.05]

        self.inter_sigma = inter_sigma
        self.multi_kernel_sizes = multi_kernel_sizes
        self.multi_sigmas = multi_sigmas
        self.multi_weights = multi_weights
        self.device = device

    @staticmethod
    def gaussian_kernel_1d(kernel_size: int, sigma: float):
        k = kernel_size // 2
        x = torch.arange(-k, k + 1, dtype=torch.float32)
        kernel = torch.exp(-(x ** 2) / (2 * sigma ** 2))
        kernel /= kernel.sum()
        return kernel

    @staticmethod
    def gaussian_kernel_2d(kernel_size: int, sigma: float, device='cuda'):
        k = kernel_size // 2
        x_coord = torch.arange(-k, k + 1, dtype=torch.float32, device=device)
        y_coord = x_coord.clone()
        xx, yy = torch.meshgrid(x_coord, y_coord, indexing='ij')
        kernel = torch.exp(-(xx ** 2 + yy ** 2) / (2 * sigma ** 2))
        kernel /= kernel.sum()
        return kernel.view(1, 1, kernel_size, kernel_size)  # [1,1,H,W]

    # ICC
    def inter_channel_smoothing(self, input_tensor: torch.Tensor, kernel_size=3):
        batch_size, channels, height, width = input_tensor.shape
        device = input_tensor.device

        kernel = self.gaussian_kernel_1d(kernel_size, self.inter_sigma).to(device)
        padding = kernel_size // 2

        weights = torch.zeros(channels, channels).to(device)
        for i in range(channels):
            start_idx = max(0, i - padding)
            end_idx = min(channels, i + padding + 1)
            kernel_slice = kernel[max(0, padding - i):kernel_size - max(0, (i + padding + 1) - channels)]
            weights[i, start_idx:end_idx] = kernel_slice

        x = input_tensor.view(batch_size, channels, -1)
        smoothed = torch.matmul(weights, x)
        return smoothed.view(batch_size, channels, height, width)

    # MSF
    def multi_scale_smoothing(self, input_tensor: torch.Tensor):
        batch_size, channels, height, width = input_tensor.shape
        device = input_tensor.device
        smoothed_tensors = []
        for kernel_size, sigma, weight in zip(self.multi_kernel_sizes, self.multi_sigmas, self.multi_weights):
            kernel = self.gaussian_kernel_2d(kernel_size, sigma, device)
            kernel = kernel.expand(channels, 1, kernel_size, kernel_size)
            smoothed = F.conv2d(input_tensor, kernel, padding=kernel_size // 2, groups=channels)
            smoothed_tensors.append(weight * smoothed)
        return sum(smoothed_tensors)

    #SAGS
    def sags(self, input_tensor: torch.Tensor):
        x = self.inter_channel_smoothing(input_tensor)
        x = self.multi_scale_smoothing(x)
        return x
